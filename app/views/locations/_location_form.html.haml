- only_inputs = [] if only_inputs.nil?
- if only_inputs.empty? || only_inputs.include?(:address)
  %div{:class => "control-group #{"error" if f.object.errors.include?(:address) || f.object.errors.include?(:latitude)}"}
    = f.label :address, :class => "control-label" do
      %abbr{:title => "required"} *
      Location address
    .controls
      = f.text_field :address, :'data-behavior' => 'address-autocomplete', :placeholder => ""
      - if f.object.errors.include?(:address) || f.object.errors.include?(:latitude)
        %p.error-block
          - if f.object.errors[:address].present?
            = f.object.errors[:address][0]
          - else
            does not exists


      .map{:style => "display: none", :'data-marker' => image_path("components/map-pin.png")}
        .map-container{:style => "height: 240px; width: 100%;"}

      = f.hidden_field :local_geocoding
      = f.hidden_field :latitude
      = f.hidden_field :longitude
      = f.hidden_field :formatted_address 
      = f.hidden_field :street
      = f.hidden_field :suburb 
      = f.hidden_field :city 
      = f.hidden_field :state
      = f.hidden_field :country
      = f.hidden_field :postcode

      #address-component-wrapper.hidden
        #address-component-template
          - # we need this input to avoid hardcoding 'name' parameter for dynamically inserted inputs for address_components
          - # i.e. in dashboard we use location[address_component], but in list your space it is user[company_attribues]... etc
          - # must be disabled, otherwise update action could overwrite existing information with empty strings!!!
          = f.input :address_components, :input_html => { :id => 'address_component_input' }, :disabled => true

= f.input :description, :label => 'Location description', :required => !f.object.listings.first.try(:description).try(:present?), :input_html => { :maxlength => 250, :rows => 2 } if only_inputs.empty? || only_inputs.include?(:description)
= f.association :location_type, :label => "Location type", :collection => platform_context.instance.location_types if only_inputs.empty? || only_inputs.include?(:location_type)
= f.input :email, :label => 'Booking email', :placeholder => 'Your booking email' if only_inputs.empty? || only_inputs.include?(:email)
= f.association :administrator, :label => 'Administrator', :collection => f.object.company_users.includes(:user).order('users.name').map(&:user), :label_method => 'name', :value_method => 'id', :input_html => { :'data-placeholder' => 'Choose a user', :class => 'custom-select' }, :include_blank => 'Default' if only_inputs.empty? || only_inputs.include?(:administrator)
= f.input :special_notes, :label => "#{platform_context.lessee.capitalize} instructions", :placeholder => "For example, how your #{platform_context.lessee.pluralize} should check in, your Wi-Fi password, whether you have pets, or other special information relevant to your #{platform_context.lessee}'s stay" if only_inputs.empty? || only_inputs.include?(:special_notes)
= f.input :currency, :as => :currency, :label => "Currency", :default => 'USD', :input_html => { :class => 'custom-select', :id => 'currency-select' } if only_inputs.empty? || only_inputs.include?(:currency)
- if only_inputs.empty? || only_inputs.include?(:availability_rules)
  .control-group
    = render :partial => 'availability_rules/form', :locals => { :f => f }
= f.association :amenities, :collection => platform_context.instance.amenity_types.order(:name), :as => :grouped_select, :group_method => :amenities, :group_label_method => :name, :label => "Amenities", :blank => false, :input_html => { 'data-placeholder' => "Select one or more", :class => 'custom-select', :multiple => true } if only_inputs.empty? || only_inputs.include?(:amenities)

