- no_footer!

- content_for :mixed_locations do
  - if g.searcher.results.present?
    .locations
      .search-max-price{:'data-max-price' => g.searcher.max_price, :'data-min-price' => g.searcher.min_price }
      .hidden-locations
        = render partial: 'search/map/location_marker', collection: g.searcher.results, as: :location
        = render partial: 'search/mixed/hidden_locations', locals: { searcher: g.searcher }

      = render 'search/mixed/pagination', searcher: g.searcher
      = render 'search/mixed/results', searcher: g.searcher
      = render 'search/mixed/pagination', searcher: g.searcher

  - elsif g.searcher.located || params[:loc]
    .locations
      .hidden-locations
        = render partial: 'search/mixed/hidden_locations', locals: { searcher: g.searcher }
      %div.no_results
        = render 'shared/loading_spinner'
        .text-center
          %br/
          %br/
          %h1.tk-adelle.fat No results found
  - else
    .locations
      .hidden-locations
        = render partial: 'search/mixed/hidden_locations', locals: { searcher: g.searcher }
      %div.no_results
        = render 'shared/loading_spinner'

- content_for :hero do
  = render 'search/mixed/header', searcher: g.searcher

  %section#results.mixed
    = render 'shared/loading_spinner'
    .map
      %section#map.google-map-wrapper
        .google-map
          #listings_map.inner{ 'data-update-text' => t('search.update_map')}
    .list{:'data-list' => true}
      .filters{:'data-search-filters-container' => true}
        -if current_instance.transactable_types.searchable.many?
          .search-mixed-filter{:'data-transactable-type-filter' => true}
            .container-fluid
              .row-fluid
                .span2
                  %h4
                    = t('search.service_type')
                .span10
                  %ul
                    - current_instance.transactable_types.searchable.each do |transactable_type|
                      %li.filter-option
                        %label.radio.small-radio
                          %input{type: 'radio', name: 'transactable_type_id', value: transactable_type.id, checked: @transactable_type.id == transactable_type.id}
                          %span.filter-label-text
                            = transactable_type.translated_bookable_noun

        - g.searcher.searchable_categories.each do |category|
          - unless category.autocomplete?
            = render partial: 'search/mixed/filter', locals: { category_id: category.id, header_name: category.translated_name, selected_values: g.searcher.category_ids || [], input_name: 'category_ids[]', options: category.category_options}
          - else
            = render partial: 'search/mixed/autocomplete_category_filter', locals: { category: category }

        #categories-children
        = render partial: 'search/shared/date_range', locals: { date_start: g.searcher.display_dates.start, date_end: g.searcher.display_dates.end }
        - g.searcher.filterable_custom_attributes.each do |ca|
          - if ca.any_valid_values_translated
            = render partial: 'search/mixed/filter', locals: { header_name: t(ca.label_key), selected_values: ca.lg_custom_attribute || [], input_name: "lg_custom_attributes[#{ca.name}][]", options: ca.valid_values_translated.map { |pair| [pair[1], pair[0]] }, name: ca.name }
        - if @transactable_type.search_price_types_filter
          = render partial: 'search/mixed/filter', locals: { header_name: 'Pricing', selected_values: g.searcher.lgpricing_filters || [], input_name: 'listing_pricing[]', options: g.searcher.filterable_pricing }
        - if @transactable_type.display_location_type_filter?
          = render :partial => 'search/mixed/filter', :locals => { :header_name => 'Location Type', :selected_values => g.searcher.location_types_ids || [], :input_name => 'location_types_ids[]', :options => g.searcher.filterable_location_types.map { |lt| [lt.id, lt.name ] } }


        - if @transactable_type.show_price_slider
          = render partial: 'search/shared/price_slider'

      .sort
        .results-count
          %h3#search_results_count
            = g.searcher.result_count
            results
        .per-page
          %span per page
          = select_tag :per_page, options_for_select(['20', '50', '100'].map{|v| [v, v]}, params[:per_page])
        = render 'search/save'

      - if not request.xhr?
        = yield :mixed_locations

- if request.xhr?
  = yield :mixed_locations

- content_for :domready do
  $(document).trigger('init:mixed:searchresults.nearme');
